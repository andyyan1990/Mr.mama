// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svg.proto

#ifndef PROTOBUF_svg_2eproto__INCLUDED
#define PROTOBUF_svg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_svg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsProtoPointImpl();
void InitDefaultsProtoPoint();
void InitDefaultsProtoCurveImpl();
void InitDefaultsProtoCurve();
void InitDefaultsProtoRectImpl();
void InitDefaultsProtoRect();
void InitDefaultsProtoColorImpl();
void InitDefaultsProtoColor();
void InitDefaultsProtoAffineTransformMatrixImpl();
void InitDefaultsProtoAffineTransformMatrix();
void InitDefaultsProtoSVGElementImpl();
void InitDefaultsProtoSVGElement();
void InitDefaultsProtoSVGPaintImpl();
void InitDefaultsProtoSVGPaint();
void InitDefaultsProtoSVGElementGradient_GradientStopImpl();
void InitDefaultsProtoSVGElementGradient_GradientStop();
void InitDefaultsProtoSVGElementPath_PathPointImpl();
void InitDefaultsProtoSVGElementPath_PathPoint();
void InitDefaultsProtoSVGRootImpl();
void InitDefaultsProtoSVGRoot();
inline void InitDefaults() {
  InitDefaultsProtoPoint();
  InitDefaultsProtoCurve();
  InitDefaultsProtoRect();
  InitDefaultsProtoColor();
  InitDefaultsProtoAffineTransformMatrix();
  InitDefaultsProtoSVGElement();
  InitDefaultsProtoSVGPaint();
  InitDefaultsProtoSVGElementGradient_GradientStop();
  InitDefaultsProtoSVGElementPath_PathPoint();
  InitDefaultsProtoSVGRoot();
}
}  // namespace protobuf_svg_2eproto
class ProtoAffineTransformMatrix;
class ProtoAffineTransformMatrixDefaultTypeInternal;
extern ProtoAffineTransformMatrixDefaultTypeInternal _ProtoAffineTransformMatrix_default_instance_;
class ProtoColor;
class ProtoColorDefaultTypeInternal;
extern ProtoColorDefaultTypeInternal _ProtoColor_default_instance_;
class ProtoCurve;
class ProtoCurveDefaultTypeInternal;
extern ProtoCurveDefaultTypeInternal _ProtoCurve_default_instance_;
class ProtoPoint;
class ProtoPointDefaultTypeInternal;
extern ProtoPointDefaultTypeInternal _ProtoPoint_default_instance_;
class ProtoRect;
class ProtoRectDefaultTypeInternal;
extern ProtoRectDefaultTypeInternal _ProtoRect_default_instance_;
class ProtoSVGElement;
class ProtoSVGElementDefaultTypeInternal;
extern ProtoSVGElementDefaultTypeInternal _ProtoSVGElement_default_instance_;
class ProtoSVGElementGradient;
class ProtoSVGElementGradientDefaultTypeInternal;
extern ProtoSVGElementGradientDefaultTypeInternal _ProtoSVGElementGradient_default_instance_;
class ProtoSVGElementGradient_GradientStop;
class ProtoSVGElementGradient_GradientStopDefaultTypeInternal;
extern ProtoSVGElementGradient_GradientStopDefaultTypeInternal _ProtoSVGElementGradient_GradientStop_default_instance_;
class ProtoSVGElementPath;
class ProtoSVGElementPathDefaultTypeInternal;
extern ProtoSVGElementPathDefaultTypeInternal _ProtoSVGElementPath_default_instance_;
class ProtoSVGElementPath_PathPoint;
class ProtoSVGElementPath_PathPointDefaultTypeInternal;
extern ProtoSVGElementPath_PathPointDefaultTypeInternal _ProtoSVGElementPath_PathPoint_default_instance_;
class ProtoSVGGeneralParams;
class ProtoSVGGeneralParamsDefaultTypeInternal;
extern ProtoSVGGeneralParamsDefaultTypeInternal _ProtoSVGGeneralParams_default_instance_;
class ProtoSVGPaint;
class ProtoSVGPaintDefaultTypeInternal;
extern ProtoSVGPaintDefaultTypeInternal _ProtoSVGPaint_default_instance_;
class ProtoSVGRoot;
class ProtoSVGRootDefaultTypeInternal;
extern ProtoSVGRootDefaultTypeInternal _ProtoSVGRoot_default_instance_;

// ===================================================================

class ProtoPoint : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoPoint) */ {
 public:
  ProtoPoint();
  virtual ~ProtoPoint();

  ProtoPoint(const ProtoPoint& from);

  inline ProtoPoint& operator=(const ProtoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoPoint(ProtoPoint&& from) noexcept
    : ProtoPoint() {
    *this = ::std::move(from);
  }

  inline ProtoPoint& operator=(ProtoPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoPoint* internal_default_instance() {
    return reinterpret_cast<const ProtoPoint*>(
               &_ProtoPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ProtoPoint* other);
  friend void swap(ProtoPoint& a, ProtoPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoPoint& from);
  void MergeFrom(const ProtoPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:ProtoPoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoPointImpl();
};
// -------------------------------------------------------------------

class ProtoCurve : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoCurve) */ {
 public:
  ProtoCurve();
  virtual ~ProtoCurve();

  ProtoCurve(const ProtoCurve& from);

  inline ProtoCurve& operator=(const ProtoCurve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoCurve(ProtoCurve&& from) noexcept
    : ProtoCurve() {
    *this = ::std::move(from);
  }

  inline ProtoCurve& operator=(ProtoCurve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoCurve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoCurve* internal_default_instance() {
    return reinterpret_cast<const ProtoCurve*>(
               &_ProtoCurve_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ProtoCurve* other);
  friend void swap(ProtoCurve& a, ProtoCurve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoCurve* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoCurve* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoCurve& from);
  void MergeFrom(const ProtoCurve& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoCurve* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float cp1x = 1;
  bool has_cp1x() const;
  void clear_cp1x();
  static const int kCp1XFieldNumber = 1;
  float cp1x() const;
  void set_cp1x(float value);

  // optional float cp1y = 2;
  bool has_cp1y() const;
  void clear_cp1y();
  static const int kCp1YFieldNumber = 2;
  float cp1y() const;
  void set_cp1y(float value);

  // optional float cp2x = 3;
  bool has_cp2x() const;
  void clear_cp2x();
  static const int kCp2XFieldNumber = 3;
  float cp2x() const;
  void set_cp2x(float value);

  // optional float cp2y = 4;
  bool has_cp2y() const;
  void clear_cp2y();
  static const int kCp2YFieldNumber = 4;
  float cp2y() const;
  void set_cp2y(float value);

  // optional float x = 5;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 5;
  float x() const;
  void set_x(float value);

  // optional float y = 6;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 6;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:ProtoCurve)
 private:
  void set_has_cp1x();
  void clear_has_cp1x();
  void set_has_cp1y();
  void clear_has_cp1y();
  void set_has_cp2x();
  void clear_has_cp2x();
  void set_has_cp2y();
  void clear_has_cp2y();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float cp1x_;
  float cp1y_;
  float cp2x_;
  float cp2y_;
  float x_;
  float y_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoCurveImpl();
};
// -------------------------------------------------------------------

class ProtoRect : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoRect) */ {
 public:
  ProtoRect();
  virtual ~ProtoRect();

  ProtoRect(const ProtoRect& from);

  inline ProtoRect& operator=(const ProtoRect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoRect(ProtoRect&& from) noexcept
    : ProtoRect() {
    *this = ::std::move(from);
  }

  inline ProtoRect& operator=(ProtoRect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoRect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoRect* internal_default_instance() {
    return reinterpret_cast<const ProtoRect*>(
               &_ProtoRect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ProtoRect* other);
  friend void swap(ProtoRect& a, ProtoRect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoRect* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoRect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoRect& from);
  void MergeFrom(const ProtoRect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float w = 3;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 3;
  float w() const;
  void set_w(float value);

  // optional float h = 4;
  bool has_h() const;
  void clear_h();
  static const int kHFieldNumber = 4;
  float h() const;
  void set_h(float value);

  // @@protoc_insertion_point(class_scope:ProtoRect)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_w();
  void clear_has_w();
  void set_has_h();
  void clear_has_h();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float w_;
  float h_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoRectImpl();
};
// -------------------------------------------------------------------

class ProtoColor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoColor) */ {
 public:
  ProtoColor();
  virtual ~ProtoColor();

  ProtoColor(const ProtoColor& from);

  inline ProtoColor& operator=(const ProtoColor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoColor(ProtoColor&& from) noexcept
    : ProtoColor() {
    *this = ::std::move(from);
  }

  inline ProtoColor& operator=(ProtoColor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoColor* internal_default_instance() {
    return reinterpret_cast<const ProtoColor*>(
               &_ProtoColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ProtoColor* other);
  friend void swap(ProtoColor& a, ProtoColor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoColor* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoColor& from);
  void MergeFrom(const ProtoColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 r = 1;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 1;
  ::google::protobuf::int32 r() const;
  void set_r(::google::protobuf::int32 value);

  // optional int32 g = 2;
  bool has_g() const;
  void clear_g();
  static const int kGFieldNumber = 2;
  ::google::protobuf::int32 g() const;
  void set_g(::google::protobuf::int32 value);

  // optional int32 b = 3;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 3;
  ::google::protobuf::int32 b() const;
  void set_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoColor)
 private:
  void set_has_r();
  void clear_has_r();
  void set_has_g();
  void clear_has_g();
  void set_has_b();
  void clear_has_b();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 r_;
  ::google::protobuf::int32 g_;
  ::google::protobuf::int32 b_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoColorImpl();
};
// -------------------------------------------------------------------

class ProtoAffineTransformMatrix : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoAffineTransformMatrix) */ {
 public:
  ProtoAffineTransformMatrix();
  virtual ~ProtoAffineTransformMatrix();

  ProtoAffineTransformMatrix(const ProtoAffineTransformMatrix& from);

  inline ProtoAffineTransformMatrix& operator=(const ProtoAffineTransformMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoAffineTransformMatrix(ProtoAffineTransformMatrix&& from) noexcept
    : ProtoAffineTransformMatrix() {
    *this = ::std::move(from);
  }

  inline ProtoAffineTransformMatrix& operator=(ProtoAffineTransformMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoAffineTransformMatrix& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoAffineTransformMatrix* internal_default_instance() {
    return reinterpret_cast<const ProtoAffineTransformMatrix*>(
               &_ProtoAffineTransformMatrix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProtoAffineTransformMatrix* other);
  friend void swap(ProtoAffineTransformMatrix& a, ProtoAffineTransformMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoAffineTransformMatrix* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoAffineTransformMatrix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoAffineTransformMatrix& from);
  void MergeFrom(const ProtoAffineTransformMatrix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoAffineTransformMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float a = 1;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 1;
  float a() const;
  void set_a(float value);

  // optional float b = 2;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 2;
  float b() const;
  void set_b(float value);

  // optional float c = 3;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 3;
  float c() const;
  void set_c(float value);

  // optional float d = 4;
  bool has_d() const;
  void clear_d();
  static const int kDFieldNumber = 4;
  float d() const;
  void set_d(float value);

  // optional float tx = 5;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 5;
  float tx() const;
  void set_tx(float value);

  // optional float ty = 6;
  bool has_ty() const;
  void clear_ty();
  static const int kTyFieldNumber = 6;
  float ty() const;
  void set_ty(float value);

  // @@protoc_insertion_point(class_scope:ProtoAffineTransformMatrix)
 private:
  void set_has_a();
  void clear_has_a();
  void set_has_b();
  void clear_has_b();
  void set_has_c();
  void clear_has_c();
  void set_has_d();
  void clear_has_d();
  void set_has_tx();
  void clear_has_tx();
  void set_has_ty();
  void clear_has_ty();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float a_;
  float b_;
  float c_;
  float d_;
  float tx_;
  float ty_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoAffineTransformMatrixImpl();
};
// -------------------------------------------------------------------

class ProtoSVGElement : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGElement) */ {
 public:
  ProtoSVGElement();
  virtual ~ProtoSVGElement();

  ProtoSVGElement(const ProtoSVGElement& from);

  inline ProtoSVGElement& operator=(const ProtoSVGElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGElement(ProtoSVGElement&& from) noexcept
    : ProtoSVGElement() {
    *this = ::std::move(from);
  }

  inline ProtoSVGElement& operator=(ProtoSVGElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGElement* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGElement*>(
               &_ProtoSVGElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ProtoSVGElement* other);
  friend void swap(ProtoSVGElement& a, ProtoSVGElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGElement* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGElement& from);
  void MergeFrom(const ProtoSVGElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoSVGGeneralParams group = 1;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 1;
  const ::ProtoSVGGeneralParams& group() const;
  ::ProtoSVGGeneralParams* release_group();
  ::ProtoSVGGeneralParams* mutable_group();
  void set_allocated_group(::ProtoSVGGeneralParams* group);

  // optional .ProtoSVGElementPath path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::ProtoSVGElementPath& path() const;
  ::ProtoSVGElementPath* release_path();
  ::ProtoSVGElementPath* mutable_path();
  void set_allocated_path(::ProtoSVGElementPath* path);

  // optional .ProtoSVGElementGradient gradient = 3;
  bool has_gradient() const;
  void clear_gradient();
  static const int kGradientFieldNumber = 3;
  const ::ProtoSVGElementGradient& gradient() const;
  ::ProtoSVGElementGradient* release_gradient();
  ::ProtoSVGElementGradient* mutable_gradient();
  void set_allocated_gradient(::ProtoSVGElementGradient* gradient);

  // optional .ProtoSVGGeneralParams defs = 4;
  bool has_defs() const;
  void clear_defs();
  static const int kDefsFieldNumber = 4;
  const ::ProtoSVGGeneralParams& defs() const;
  ::ProtoSVGGeneralParams* release_defs();
  ::ProtoSVGGeneralParams* mutable_defs();
  void set_allocated_defs(::ProtoSVGGeneralParams* defs);

  // @@protoc_insertion_point(class_scope:ProtoSVGElement)
 private:
  void set_has_group();
  void clear_has_group();
  void set_has_path();
  void clear_has_path();
  void set_has_gradient();
  void clear_has_gradient();
  void set_has_defs();
  void clear_has_defs();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ProtoSVGGeneralParams* group_;
  ::ProtoSVGElementPath* path_;
  ::ProtoSVGElementGradient* gradient_;
  ::ProtoSVGGeneralParams* defs_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementImpl();
};
// -------------------------------------------------------------------

class ProtoSVGPaint : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGPaint) */ {
 public:
  ProtoSVGPaint();
  virtual ~ProtoSVGPaint();

  ProtoSVGPaint(const ProtoSVGPaint& from);

  inline ProtoSVGPaint& operator=(const ProtoSVGPaint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGPaint(ProtoSVGPaint&& from) noexcept
    : ProtoSVGPaint() {
    *this = ::std::move(from);
  }

  inline ProtoSVGPaint& operator=(ProtoSVGPaint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGPaint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGPaint* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGPaint*>(
               &_ProtoSVGPaint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ProtoSVGPaint* other);
  friend void swap(ProtoSVGPaint& a, ProtoSVGPaint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGPaint* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGPaint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGPaint& from);
  void MergeFrom(const ProtoSVGPaint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGPaint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ref_id = 2;
  bool has_ref_id() const;
  void clear_ref_id();
  static const int kRefIdFieldNumber = 2;
  const ::std::string& ref_id() const;
  void set_ref_id(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_id(::std::string&& value);
  #endif
  void set_ref_id(const char* value);
  void set_ref_id(const char* value, size_t size);
  ::std::string* mutable_ref_id();
  ::std::string* release_ref_id();
  void set_allocated_ref_id(::std::string* ref_id);

  // optional .ProtoColor color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  const ::ProtoColor& color() const;
  ::ProtoColor* release_color();
  ::ProtoColor* mutable_color();
  void set_allocated_color(::ProtoColor* color);

  // optional bool paint_off = 3;
  bool has_paint_off() const;
  void clear_paint_off();
  static const int kPaintOffFieldNumber = 3;
  bool paint_off() const;
  void set_paint_off(bool value);

  // optional bool odd = 4 [default = false];
  bool has_odd() const;
  void clear_odd();
  static const int kOddFieldNumber = 4;
  bool odd() const;
  void set_odd(bool value);

  // optional float stroke_width = 5 [default = 1];
  bool has_stroke_width() const;
  void clear_stroke_width();
  static const int kStrokeWidthFieldNumber = 5;
  float stroke_width() const;
  void set_stroke_width(float value);

  // @@protoc_insertion_point(class_scope:ProtoSVGPaint)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_ref_id();
  void clear_has_ref_id();
  void set_has_paint_off();
  void clear_has_paint_off();
  void set_has_odd();
  void clear_has_odd();
  void set_has_stroke_width();
  void clear_has_stroke_width();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ref_id_;
  ::ProtoColor* color_;
  bool paint_off_;
  bool odd_;
  float stroke_width_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGPaintImpl();
};
// -------------------------------------------------------------------

class ProtoSVGGeneralParams : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGGeneralParams) */ {
 public:
  ProtoSVGGeneralParams();
  virtual ~ProtoSVGGeneralParams();

  ProtoSVGGeneralParams(const ProtoSVGGeneralParams& from);

  inline ProtoSVGGeneralParams& operator=(const ProtoSVGGeneralParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGGeneralParams(ProtoSVGGeneralParams&& from) noexcept
    : ProtoSVGGeneralParams() {
    *this = ::std::move(from);
  }

  inline ProtoSVGGeneralParams& operator=(ProtoSVGGeneralParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGGeneralParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGGeneralParams* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGGeneralParams*>(
               &_ProtoSVGGeneralParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ProtoSVGGeneralParams* other);
  friend void swap(ProtoSVGGeneralParams& a, ProtoSVGGeneralParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGGeneralParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGGeneralParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGGeneralParams& from);
  void MergeFrom(const ProtoSVGGeneralParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGGeneralParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ProtoSVGElement childs = 1;
  int childs_size() const;
  void clear_childs();
  static const int kChildsFieldNumber = 1;
  const ::ProtoSVGElement& childs(int index) const;
  ::ProtoSVGElement* mutable_childs(int index);
  ::ProtoSVGElement* add_childs();
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElement >*
      mutable_childs();
  const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElement >&
      childs() const;

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .ProtoSVGPaint fill = 3;
  bool has_fill() const;
  void clear_fill();
  static const int kFillFieldNumber = 3;
  const ::ProtoSVGPaint& fill() const;
  ::ProtoSVGPaint* release_fill();
  ::ProtoSVGPaint* mutable_fill();
  void set_allocated_fill(::ProtoSVGPaint* fill);

  // optional .ProtoSVGPaint stroke = 4;
  bool has_stroke() const;
  void clear_stroke();
  static const int kStrokeFieldNumber = 4;
  const ::ProtoSVGPaint& stroke() const;
  ::ProtoSVGPaint* release_stroke();
  ::ProtoSVGPaint* mutable_stroke();
  void set_allocated_stroke(::ProtoSVGPaint* stroke);

  // optional .ProtoAffineTransformMatrix transform = 5;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 5;
  const ::ProtoAffineTransformMatrix& transform() const;
  ::ProtoAffineTransformMatrix* release_transform();
  ::ProtoAffineTransformMatrix* mutable_transform();
  void set_allocated_transform(::ProtoAffineTransformMatrix* transform);

  // optional float opacity = 6 [default = 1];
  bool has_opacity() const;
  void clear_opacity();
  static const int kOpacityFieldNumber = 6;
  float opacity() const;
  void set_opacity(float value);

  // @@protoc_insertion_point(class_scope:ProtoSVGGeneralParams)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_fill();
  void clear_has_fill();
  void set_has_stroke();
  void clear_has_stroke();
  void set_has_transform();
  void clear_has_transform();
  void set_has_opacity();
  void clear_has_opacity();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElement > childs_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ProtoSVGPaint* fill_;
  ::ProtoSVGPaint* stroke_;
  ::ProtoAffineTransformMatrix* transform_;
  float opacity_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementImpl();
};
// -------------------------------------------------------------------

class ProtoSVGElementGradient_GradientStop : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGElementGradient.GradientStop) */ {
 public:
  ProtoSVGElementGradient_GradientStop();
  virtual ~ProtoSVGElementGradient_GradientStop();

  ProtoSVGElementGradient_GradientStop(const ProtoSVGElementGradient_GradientStop& from);

  inline ProtoSVGElementGradient_GradientStop& operator=(const ProtoSVGElementGradient_GradientStop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGElementGradient_GradientStop(ProtoSVGElementGradient_GradientStop&& from) noexcept
    : ProtoSVGElementGradient_GradientStop() {
    *this = ::std::move(from);
  }

  inline ProtoSVGElementGradient_GradientStop& operator=(ProtoSVGElementGradient_GradientStop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGElementGradient_GradientStop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGElementGradient_GradientStop* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGElementGradient_GradientStop*>(
               &_ProtoSVGElementGradient_GradientStop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ProtoSVGElementGradient_GradientStop* other);
  friend void swap(ProtoSVGElementGradient_GradientStop& a, ProtoSVGElementGradient_GradientStop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGElementGradient_GradientStop* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGElementGradient_GradientStop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGElementGradient_GradientStop& from);
  void MergeFrom(const ProtoSVGElementGradient_GradientStop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGElementGradient_GradientStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoColor color = 2;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 2;
  const ::ProtoColor& color() const;
  ::ProtoColor* release_color();
  ::ProtoColor* mutable_color();
  void set_allocated_color(::ProtoColor* color);

  // optional float offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  float offset() const;
  void set_offset(float value);

  // optional float alpha = 3;
  bool has_alpha() const;
  void clear_alpha();
  static const int kAlphaFieldNumber = 3;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:ProtoSVGElementGradient.GradientStop)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_color();
  void clear_has_color();
  void set_has_alpha();
  void clear_has_alpha();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ProtoColor* color_;
  float offset_;
  float alpha_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementGradient_GradientStopImpl();
};
// -------------------------------------------------------------------

class ProtoSVGElementGradient : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGElementGradient) */ {
 public:
  ProtoSVGElementGradient();
  virtual ~ProtoSVGElementGradient();

  ProtoSVGElementGradient(const ProtoSVGElementGradient& from);

  inline ProtoSVGElementGradient& operator=(const ProtoSVGElementGradient& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGElementGradient(ProtoSVGElementGradient&& from) noexcept
    : ProtoSVGElementGradient() {
    *this = ::std::move(from);
  }

  inline ProtoSVGElementGradient& operator=(ProtoSVGElementGradient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGElementGradient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGElementGradient* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGElementGradient*>(
               &_ProtoSVGElementGradient_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ProtoSVGElementGradient* other);
  friend void swap(ProtoSVGElementGradient& a, ProtoSVGElementGradient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGElementGradient* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGElementGradient* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGElementGradient& from);
  void MergeFrom(const ProtoSVGElementGradient& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGElementGradient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ProtoSVGElementGradient_GradientStop GradientStop;

  // accessors -------------------------------------------------------

  // repeated .ProtoSVGElementGradient.GradientStop stops = 3;
  int stops_size() const;
  void clear_stops();
  static const int kStopsFieldNumber = 3;
  const ::ProtoSVGElementGradient_GradientStop& stops(int index) const;
  ::ProtoSVGElementGradient_GradientStop* mutable_stops(int index);
  ::ProtoSVGElementGradient_GradientStop* add_stops();
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementGradient_GradientStop >*
      mutable_stops();
  const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementGradient_GradientStop >&
      stops() const;

  // optional .ProtoSVGGeneralParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  const ::ProtoSVGGeneralParams& params() const;
  ::ProtoSVGGeneralParams* release_params();
  ::ProtoSVGGeneralParams* mutable_params();
  void set_allocated_params(::ProtoSVGGeneralParams* params);

  // optional .ProtoAffineTransformMatrix gradientTransform = 4;
  bool has_gradienttransform() const;
  void clear_gradienttransform();
  static const int kGradientTransformFieldNumber = 4;
  const ::ProtoAffineTransformMatrix& gradienttransform() const;
  ::ProtoAffineTransformMatrix* release_gradienttransform();
  ::ProtoAffineTransformMatrix* mutable_gradienttransform();
  void set_allocated_gradienttransform(::ProtoAffineTransformMatrix* gradienttransform);

  // optional .ProtoPoint startPoint = 5;
  bool has_startpoint() const;
  void clear_startpoint();
  static const int kStartPointFieldNumber = 5;
  const ::ProtoPoint& startpoint() const;
  ::ProtoPoint* release_startpoint();
  ::ProtoPoint* mutable_startpoint();
  void set_allocated_startpoint(::ProtoPoint* startpoint);

  // optional .ProtoPoint endPoint = 6;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndPointFieldNumber = 6;
  const ::ProtoPoint& endpoint() const;
  ::ProtoPoint* release_endpoint();
  ::ProtoPoint* mutable_endpoint();
  void set_allocated_endpoint(::ProtoPoint* endpoint);

  // optional .ProtoPoint center = 7;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 7;
  const ::ProtoPoint& center() const;
  ::ProtoPoint* release_center();
  ::ProtoPoint* mutable_center();
  void set_allocated_center(::ProtoPoint* center);

  // optional .ProtoPoint focusPoint = 9;
  bool has_focuspoint() const;
  void clear_focuspoint();
  static const int kFocusPointFieldNumber = 9;
  const ::ProtoPoint& focuspoint() const;
  ::ProtoPoint* release_focuspoint();
  ::ProtoPoint* mutable_focuspoint();
  void set_allocated_focuspoint(::ProtoPoint* focuspoint);

  // optional float r = 8;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 8;
  float r() const;
  void set_r(float value);

  // optional bool gradientUnits_IsUserSpace = 10 [default = true];
  bool has_gradientunits_isuserspace() const;
  void clear_gradientunits_isuserspace();
  static const int kGradientUnitsIsUserSpaceFieldNumber = 10;
  bool gradientunits_isuserspace() const;
  void set_gradientunits_isuserspace(bool value);

  // @@protoc_insertion_point(class_scope:ProtoSVGElementGradient)
 private:
  void set_has_params();
  void clear_has_params();
  void set_has_gradienttransform();
  void clear_has_gradienttransform();
  void set_has_startpoint();
  void clear_has_startpoint();
  void set_has_endpoint();
  void clear_has_endpoint();
  void set_has_center();
  void clear_has_center();
  void set_has_r();
  void clear_has_r();
  void set_has_focuspoint();
  void clear_has_focuspoint();
  void set_has_gradientunits_isuserspace();
  void clear_has_gradientunits_isuserspace();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementGradient_GradientStop > stops_;
  ::ProtoSVGGeneralParams* params_;
  ::ProtoAffineTransformMatrix* gradienttransform_;
  ::ProtoPoint* startpoint_;
  ::ProtoPoint* endpoint_;
  ::ProtoPoint* center_;
  ::ProtoPoint* focuspoint_;
  float r_;
  bool gradientunits_isuserspace_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementImpl();
};
// -------------------------------------------------------------------

class ProtoSVGElementPath_PathPoint : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGElementPath.PathPoint) */ {
 public:
  ProtoSVGElementPath_PathPoint();
  virtual ~ProtoSVGElementPath_PathPoint();

  ProtoSVGElementPath_PathPoint(const ProtoSVGElementPath_PathPoint& from);

  inline ProtoSVGElementPath_PathPoint& operator=(const ProtoSVGElementPath_PathPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGElementPath_PathPoint(ProtoSVGElementPath_PathPoint&& from) noexcept
    : ProtoSVGElementPath_PathPoint() {
    *this = ::std::move(from);
  }

  inline ProtoSVGElementPath_PathPoint& operator=(ProtoSVGElementPath_PathPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGElementPath_PathPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGElementPath_PathPoint* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGElementPath_PathPoint*>(
               &_ProtoSVGElementPath_PathPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ProtoSVGElementPath_PathPoint* other);
  friend void swap(ProtoSVGElementPath_PathPoint& a, ProtoSVGElementPath_PathPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGElementPath_PathPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGElementPath_PathPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGElementPath_PathPoint& from);
  void MergeFrom(const ProtoSVGElementPath_PathPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGElementPath_PathPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoPoint move_to = 1;
  bool has_move_to() const;
  void clear_move_to();
  static const int kMoveToFieldNumber = 1;
  const ::ProtoPoint& move_to() const;
  ::ProtoPoint* release_move_to();
  ::ProtoPoint* mutable_move_to();
  void set_allocated_move_to(::ProtoPoint* move_to);

  // optional .ProtoPoint line_to = 2;
  bool has_line_to() const;
  void clear_line_to();
  static const int kLineToFieldNumber = 2;
  const ::ProtoPoint& line_to() const;
  ::ProtoPoint* release_line_to();
  ::ProtoPoint* mutable_line_to();
  void set_allocated_line_to(::ProtoPoint* line_to);

  // optional .ProtoCurve curve_to = 3;
  bool has_curve_to() const;
  void clear_curve_to();
  static const int kCurveToFieldNumber = 3;
  const ::ProtoCurve& curve_to() const;
  ::ProtoCurve* release_curve_to();
  ::ProtoCurve* mutable_curve_to();
  void set_allocated_curve_to(::ProtoCurve* curve_to);

  // optional bool close_path = 4 [default = false];
  bool has_close_path() const;
  void clear_close_path();
  static const int kClosePathFieldNumber = 4;
  bool close_path() const;
  void set_close_path(bool value);

  // @@protoc_insertion_point(class_scope:ProtoSVGElementPath.PathPoint)
 private:
  void set_has_move_to();
  void clear_has_move_to();
  void set_has_line_to();
  void clear_has_line_to();
  void set_has_curve_to();
  void clear_has_curve_to();
  void set_has_close_path();
  void clear_has_close_path();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ProtoPoint* move_to_;
  ::ProtoPoint* line_to_;
  ::ProtoCurve* curve_to_;
  bool close_path_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementPath_PathPointImpl();
};
// -------------------------------------------------------------------

class ProtoSVGElementPath : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGElementPath) */ {
 public:
  ProtoSVGElementPath();
  virtual ~ProtoSVGElementPath();

  ProtoSVGElementPath(const ProtoSVGElementPath& from);

  inline ProtoSVGElementPath& operator=(const ProtoSVGElementPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGElementPath(ProtoSVGElementPath&& from) noexcept
    : ProtoSVGElementPath() {
    *this = ::std::move(from);
  }

  inline ProtoSVGElementPath& operator=(ProtoSVGElementPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGElementPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGElementPath* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGElementPath*>(
               &_ProtoSVGElementPath_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ProtoSVGElementPath* other);
  friend void swap(ProtoSVGElementPath& a, ProtoSVGElementPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGElementPath* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGElementPath* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGElementPath& from);
  void MergeFrom(const ProtoSVGElementPath& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGElementPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ProtoSVGElementPath_PathPoint PathPoint;

  // accessors -------------------------------------------------------

  // repeated .ProtoSVGElementPath.PathPoint points = 3;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  const ::ProtoSVGElementPath_PathPoint& points(int index) const;
  ::ProtoSVGElementPath_PathPoint* mutable_points(int index);
  ::ProtoSVGElementPath_PathPoint* add_points();
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementPath_PathPoint >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementPath_PathPoint >&
      points() const;

  // optional .ProtoSVGGeneralParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  const ::ProtoSVGGeneralParams& params() const;
  ::ProtoSVGGeneralParams* release_params();
  ::ProtoSVGGeneralParams* mutable_params();
  void set_allocated_params(::ProtoSVGGeneralParams* params);

  // optional .ProtoRect rect = 9;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 9;
  const ::ProtoRect& rect() const;
  ::ProtoRect* release_rect();
  ::ProtoRect* mutable_rect();
  void set_allocated_rect(::ProtoRect* rect);

  // optional float cx = 4;
  bool has_cx() const;
  void clear_cx();
  static const int kCxFieldNumber = 4;
  float cx() const;
  void set_cx(float value);

  // optional float cy = 5;
  bool has_cy() const;
  void clear_cy();
  static const int kCyFieldNumber = 5;
  float cy() const;
  void set_cy(float value);

  // optional float rx = 6;
  bool has_rx() const;
  void clear_rx();
  static const int kRxFieldNumber = 6;
  float rx() const;
  void set_rx(float value);

  // optional float ry = 7;
  bool has_ry() const;
  void clear_ry();
  static const int kRyFieldNumber = 7;
  float ry() const;
  void set_ry(float value);

  // optional float r = 8;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 8;
  float r() const;
  void set_r(float value);

  // @@protoc_insertion_point(class_scope:ProtoSVGElementPath)
 private:
  void set_has_params();
  void clear_has_params();
  void set_has_cx();
  void clear_has_cx();
  void set_has_cy();
  void clear_has_cy();
  void set_has_rx();
  void clear_has_rx();
  void set_has_ry();
  void clear_has_ry();
  void set_has_r();
  void clear_has_r();
  void set_has_rect();
  void clear_has_rect();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementPath_PathPoint > points_;
  ::ProtoSVGGeneralParams* params_;
  ::ProtoRect* rect_;
  float cx_;
  float cy_;
  float rx_;
  float ry_;
  float r_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGElementImpl();
};
// -------------------------------------------------------------------

class ProtoSVGRoot : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:ProtoSVGRoot) */ {
 public:
  ProtoSVGRoot();
  virtual ~ProtoSVGRoot();

  ProtoSVGRoot(const ProtoSVGRoot& from);

  inline ProtoSVGRoot& operator=(const ProtoSVGRoot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtoSVGRoot(ProtoSVGRoot&& from) noexcept
    : ProtoSVGRoot() {
    *this = ::std::move(from);
  }

  inline ProtoSVGRoot& operator=(ProtoSVGRoot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ProtoSVGRoot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtoSVGRoot* internal_default_instance() {
    return reinterpret_cast<const ProtoSVGRoot*>(
               &_ProtoSVGRoot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ProtoSVGRoot* other);
  friend void swap(ProtoSVGRoot& a, ProtoSVGRoot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtoSVGRoot* New() const PROTOBUF_FINAL { return New(NULL); }

  ProtoSVGRoot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ProtoSVGRoot& from);
  void MergeFrom(const ProtoSVGRoot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProtoSVGRoot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoSVGGeneralParams params = 1;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  const ::ProtoSVGGeneralParams& params() const;
  ::ProtoSVGGeneralParams* release_params();
  ::ProtoSVGGeneralParams* mutable_params();
  void set_allocated_params(::ProtoSVGGeneralParams* params);

  // optional .ProtoRect frame = 2;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 2;
  const ::ProtoRect& frame() const;
  ::ProtoRect* release_frame();
  ::ProtoRect* mutable_frame();
  void set_allocated_frame(::ProtoRect* frame);

  // optional .ProtoRect bounds = 3;
  bool has_bounds() const;
  void clear_bounds();
  static const int kBoundsFieldNumber = 3;
  const ::ProtoRect& bounds() const;
  ::ProtoRect* release_bounds();
  ::ProtoRect* mutable_bounds();
  void set_allocated_bounds(::ProtoRect* bounds);

  // @@protoc_insertion_point(class_scope:ProtoSVGRoot)
 private:
  void set_has_params();
  void clear_has_params();
  void set_has_frame();
  void clear_has_frame();
  void set_has_bounds();
  void clear_has_bounds();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ProtoSVGGeneralParams* params_;
  ::ProtoRect* frame_;
  ::ProtoRect* bounds_;
  friend struct ::protobuf_svg_2eproto::TableStruct;
  friend void ::protobuf_svg_2eproto::InitDefaultsProtoSVGRootImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoPoint

// optional float x = 1;
inline bool ProtoPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ProtoPoint::x() const {
  // @@protoc_insertion_point(field_get:ProtoPoint.x)
  return x_;
}
inline void ProtoPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ProtoPoint.x)
}

// optional float y = 2;
inline bool ProtoPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ProtoPoint::y() const {
  // @@protoc_insertion_point(field_get:ProtoPoint.y)
  return y_;
}
inline void ProtoPoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ProtoPoint.y)
}

// -------------------------------------------------------------------

// ProtoCurve

// optional float cp1x = 1;
inline bool ProtoCurve::has_cp1x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoCurve::set_has_cp1x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoCurve::clear_has_cp1x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoCurve::clear_cp1x() {
  cp1x_ = 0;
  clear_has_cp1x();
}
inline float ProtoCurve::cp1x() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.cp1x)
  return cp1x_;
}
inline void ProtoCurve::set_cp1x(float value) {
  set_has_cp1x();
  cp1x_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.cp1x)
}

// optional float cp1y = 2;
inline bool ProtoCurve::has_cp1y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoCurve::set_has_cp1y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoCurve::clear_has_cp1y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoCurve::clear_cp1y() {
  cp1y_ = 0;
  clear_has_cp1y();
}
inline float ProtoCurve::cp1y() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.cp1y)
  return cp1y_;
}
inline void ProtoCurve::set_cp1y(float value) {
  set_has_cp1y();
  cp1y_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.cp1y)
}

// optional float cp2x = 3;
inline bool ProtoCurve::has_cp2x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoCurve::set_has_cp2x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoCurve::clear_has_cp2x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoCurve::clear_cp2x() {
  cp2x_ = 0;
  clear_has_cp2x();
}
inline float ProtoCurve::cp2x() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.cp2x)
  return cp2x_;
}
inline void ProtoCurve::set_cp2x(float value) {
  set_has_cp2x();
  cp2x_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.cp2x)
}

// optional float cp2y = 4;
inline bool ProtoCurve::has_cp2y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoCurve::set_has_cp2y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoCurve::clear_has_cp2y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoCurve::clear_cp2y() {
  cp2y_ = 0;
  clear_has_cp2y();
}
inline float ProtoCurve::cp2y() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.cp2y)
  return cp2y_;
}
inline void ProtoCurve::set_cp2y(float value) {
  set_has_cp2y();
  cp2y_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.cp2y)
}

// optional float x = 5;
inline bool ProtoCurve::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoCurve::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoCurve::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoCurve::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ProtoCurve::x() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.x)
  return x_;
}
inline void ProtoCurve::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.x)
}

// optional float y = 6;
inline bool ProtoCurve::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoCurve::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoCurve::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoCurve::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ProtoCurve::y() const {
  // @@protoc_insertion_point(field_get:ProtoCurve.y)
  return y_;
}
inline void ProtoCurve::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ProtoCurve.y)
}

// -------------------------------------------------------------------

// ProtoRect

// optional float x = 1;
inline bool ProtoRect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoRect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoRect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoRect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ProtoRect::x() const {
  // @@protoc_insertion_point(field_get:ProtoRect.x)
  return x_;
}
inline void ProtoRect::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ProtoRect.x)
}

// optional float y = 2;
inline bool ProtoRect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoRect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoRect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoRect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ProtoRect::y() const {
  // @@protoc_insertion_point(field_get:ProtoRect.y)
  return y_;
}
inline void ProtoRect::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ProtoRect.y)
}

// optional float w = 3;
inline bool ProtoRect::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoRect::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoRect::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoRect::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float ProtoRect::w() const {
  // @@protoc_insertion_point(field_get:ProtoRect.w)
  return w_;
}
inline void ProtoRect::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ProtoRect.w)
}

// optional float h = 4;
inline bool ProtoRect::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoRect::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoRect::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoRect::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float ProtoRect::h() const {
  // @@protoc_insertion_point(field_get:ProtoRect.h)
  return h_;
}
inline void ProtoRect::set_h(float value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:ProtoRect.h)
}

// -------------------------------------------------------------------

// ProtoColor

// optional int32 r = 1;
inline bool ProtoColor::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoColor::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoColor::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoColor::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 ProtoColor::r() const {
  // @@protoc_insertion_point(field_get:ProtoColor.r)
  return r_;
}
inline void ProtoColor::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:ProtoColor.r)
}

// optional int32 g = 2;
inline bool ProtoColor::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoColor::set_has_g() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoColor::clear_has_g() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoColor::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline ::google::protobuf::int32 ProtoColor::g() const {
  // @@protoc_insertion_point(field_get:ProtoColor.g)
  return g_;
}
inline void ProtoColor::set_g(::google::protobuf::int32 value) {
  set_has_g();
  g_ = value;
  // @@protoc_insertion_point(field_set:ProtoColor.g)
}

// optional int32 b = 3;
inline bool ProtoColor::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoColor::set_has_b() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoColor::clear_has_b() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoColor::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline ::google::protobuf::int32 ProtoColor::b() const {
  // @@protoc_insertion_point(field_get:ProtoColor.b)
  return b_;
}
inline void ProtoColor::set_b(::google::protobuf::int32 value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:ProtoColor.b)
}

// -------------------------------------------------------------------

// ProtoAffineTransformMatrix

// optional float a = 1;
inline bool ProtoAffineTransformMatrix::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoAffineTransformMatrix::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoAffineTransformMatrix::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float ProtoAffineTransformMatrix::a() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.a)
  return a_;
}
inline void ProtoAffineTransformMatrix::set_a(float value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.a)
}

// optional float b = 2;
inline bool ProtoAffineTransformMatrix::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoAffineTransformMatrix::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoAffineTransformMatrix::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float ProtoAffineTransformMatrix::b() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.b)
  return b_;
}
inline void ProtoAffineTransformMatrix::set_b(float value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.b)
}

// optional float c = 3;
inline bool ProtoAffineTransformMatrix::has_c() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_c() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoAffineTransformMatrix::clear_has_c() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoAffineTransformMatrix::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline float ProtoAffineTransformMatrix::c() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.c)
  return c_;
}
inline void ProtoAffineTransformMatrix::set_c(float value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.c)
}

// optional float d = 4;
inline bool ProtoAffineTransformMatrix::has_d() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_d() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoAffineTransformMatrix::clear_has_d() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoAffineTransformMatrix::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline float ProtoAffineTransformMatrix::d() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.d)
  return d_;
}
inline void ProtoAffineTransformMatrix::set_d(float value) {
  set_has_d();
  d_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.d)
}

// optional float tx = 5;
inline bool ProtoAffineTransformMatrix::has_tx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_tx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoAffineTransformMatrix::clear_has_tx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoAffineTransformMatrix::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline float ProtoAffineTransformMatrix::tx() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.tx)
  return tx_;
}
inline void ProtoAffineTransformMatrix::set_tx(float value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.tx)
}

// optional float ty = 6;
inline bool ProtoAffineTransformMatrix::has_ty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoAffineTransformMatrix::set_has_ty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoAffineTransformMatrix::clear_has_ty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoAffineTransformMatrix::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline float ProtoAffineTransformMatrix::ty() const {
  // @@protoc_insertion_point(field_get:ProtoAffineTransformMatrix.ty)
  return ty_;
}
inline void ProtoAffineTransformMatrix::set_ty(float value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:ProtoAffineTransformMatrix.ty)
}

// -------------------------------------------------------------------

// ProtoSVGElement

// optional .ProtoSVGGeneralParams group = 1;
inline bool ProtoSVGElement::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGElement::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGElement::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGElement::clear_group() {
  if (group_ != NULL) group_->Clear();
  clear_has_group();
}
inline const ::ProtoSVGGeneralParams& ProtoSVGElement::group() const {
  const ::ProtoSVGGeneralParams* p = group_;
  // @@protoc_insertion_point(field_get:ProtoSVGElement.group)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGGeneralParams*>(
      &::_ProtoSVGGeneralParams_default_instance_);
}
inline ::ProtoSVGGeneralParams* ProtoSVGElement::release_group() {
  // @@protoc_insertion_point(field_release:ProtoSVGElement.group)
  clear_has_group();
  ::ProtoSVGGeneralParams* temp = group_;
  group_ = NULL;
  return temp;
}
inline ::ProtoSVGGeneralParams* ProtoSVGElement::mutable_group() {
  set_has_group();
  if (group_ == NULL) {
    group_ = new ::ProtoSVGGeneralParams;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElement.group)
  return group_;
}
inline void ProtoSVGElement::set_allocated_group(::ProtoSVGGeneralParams* group) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete group_;
  }
  if (group) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      group = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    set_has_group();
  } else {
    clear_has_group();
  }
  group_ = group;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElement.group)
}

// optional .ProtoSVGElementPath path = 2;
inline bool ProtoSVGElement::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGElement::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGElement::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGElement::clear_path() {
  if (path_ != NULL) path_->Clear();
  clear_has_path();
}
inline const ::ProtoSVGElementPath& ProtoSVGElement::path() const {
  const ::ProtoSVGElementPath* p = path_;
  // @@protoc_insertion_point(field_get:ProtoSVGElement.path)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGElementPath*>(
      &::_ProtoSVGElementPath_default_instance_);
}
inline ::ProtoSVGElementPath* ProtoSVGElement::release_path() {
  // @@protoc_insertion_point(field_release:ProtoSVGElement.path)
  clear_has_path();
  ::ProtoSVGElementPath* temp = path_;
  path_ = NULL;
  return temp;
}
inline ::ProtoSVGElementPath* ProtoSVGElement::mutable_path() {
  set_has_path();
  if (path_ == NULL) {
    path_ = new ::ProtoSVGElementPath;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElement.path)
  return path_;
}
inline void ProtoSVGElement::set_allocated_path(::ProtoSVGElementPath* path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_;
  }
  if (path) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    set_has_path();
  } else {
    clear_has_path();
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElement.path)
}

// optional .ProtoSVGElementGradient gradient = 3;
inline bool ProtoSVGElement::has_gradient() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGElement::set_has_gradient() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGElement::clear_has_gradient() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGElement::clear_gradient() {
  if (gradient_ != NULL) gradient_->Clear();
  clear_has_gradient();
}
inline const ::ProtoSVGElementGradient& ProtoSVGElement::gradient() const {
  const ::ProtoSVGElementGradient* p = gradient_;
  // @@protoc_insertion_point(field_get:ProtoSVGElement.gradient)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGElementGradient*>(
      &::_ProtoSVGElementGradient_default_instance_);
}
inline ::ProtoSVGElementGradient* ProtoSVGElement::release_gradient() {
  // @@protoc_insertion_point(field_release:ProtoSVGElement.gradient)
  clear_has_gradient();
  ::ProtoSVGElementGradient* temp = gradient_;
  gradient_ = NULL;
  return temp;
}
inline ::ProtoSVGElementGradient* ProtoSVGElement::mutable_gradient() {
  set_has_gradient();
  if (gradient_ == NULL) {
    gradient_ = new ::ProtoSVGElementGradient;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElement.gradient)
  return gradient_;
}
inline void ProtoSVGElement::set_allocated_gradient(::ProtoSVGElementGradient* gradient) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gradient_;
  }
  if (gradient) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gradient = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gradient, submessage_arena);
    }
    set_has_gradient();
  } else {
    clear_has_gradient();
  }
  gradient_ = gradient;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElement.gradient)
}

// optional .ProtoSVGGeneralParams defs = 4;
inline bool ProtoSVGElement::has_defs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGElement::set_has_defs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGElement::clear_has_defs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGElement::clear_defs() {
  if (defs_ != NULL) defs_->Clear();
  clear_has_defs();
}
inline const ::ProtoSVGGeneralParams& ProtoSVGElement::defs() const {
  const ::ProtoSVGGeneralParams* p = defs_;
  // @@protoc_insertion_point(field_get:ProtoSVGElement.defs)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGGeneralParams*>(
      &::_ProtoSVGGeneralParams_default_instance_);
}
inline ::ProtoSVGGeneralParams* ProtoSVGElement::release_defs() {
  // @@protoc_insertion_point(field_release:ProtoSVGElement.defs)
  clear_has_defs();
  ::ProtoSVGGeneralParams* temp = defs_;
  defs_ = NULL;
  return temp;
}
inline ::ProtoSVGGeneralParams* ProtoSVGElement::mutable_defs() {
  set_has_defs();
  if (defs_ == NULL) {
    defs_ = new ::ProtoSVGGeneralParams;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElement.defs)
  return defs_;
}
inline void ProtoSVGElement::set_allocated_defs(::ProtoSVGGeneralParams* defs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete defs_;
  }
  if (defs) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      defs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, defs, submessage_arena);
    }
    set_has_defs();
  } else {
    clear_has_defs();
  }
  defs_ = defs;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElement.defs)
}

// -------------------------------------------------------------------

// ProtoSVGPaint

// optional .ProtoColor color = 1;
inline bool ProtoSVGPaint::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGPaint::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGPaint::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGPaint::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::ProtoColor& ProtoSVGPaint::color() const {
  const ::ProtoColor* p = color_;
  // @@protoc_insertion_point(field_get:ProtoSVGPaint.color)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoColor*>(
      &::_ProtoColor_default_instance_);
}
inline ::ProtoColor* ProtoSVGPaint::release_color() {
  // @@protoc_insertion_point(field_release:ProtoSVGPaint.color)
  clear_has_color();
  ::ProtoColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::ProtoColor* ProtoSVGPaint::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    color_ = new ::ProtoColor;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGPaint.color)
  return color_;
}
inline void ProtoSVGPaint::set_allocated_color(::ProtoColor* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGPaint.color)
}

// optional string ref_id = 2;
inline bool ProtoSVGPaint::has_ref_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGPaint::set_has_ref_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGPaint::clear_has_ref_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGPaint::clear_ref_id() {
  ref_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ref_id();
}
inline const ::std::string& ProtoSVGPaint::ref_id() const {
  // @@protoc_insertion_point(field_get:ProtoSVGPaint.ref_id)
  return ref_id_.GetNoArena();
}
inline void ProtoSVGPaint::set_ref_id(const ::std::string& value) {
  set_has_ref_id();
  ref_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ProtoSVGPaint.ref_id)
}
#if LANG_CXX11
inline void ProtoSVGPaint::set_ref_id(::std::string&& value) {
  set_has_ref_id();
  ref_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ProtoSVGPaint.ref_id)
}
#endif
inline void ProtoSVGPaint::set_ref_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ref_id();
  ref_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ProtoSVGPaint.ref_id)
}
inline void ProtoSVGPaint::set_ref_id(const char* value, size_t size) {
  set_has_ref_id();
  ref_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ProtoSVGPaint.ref_id)
}
inline ::std::string* ProtoSVGPaint::mutable_ref_id() {
  set_has_ref_id();
  // @@protoc_insertion_point(field_mutable:ProtoSVGPaint.ref_id)
  return ref_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoSVGPaint::release_ref_id() {
  // @@protoc_insertion_point(field_release:ProtoSVGPaint.ref_id)
  clear_has_ref_id();
  return ref_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoSVGPaint::set_allocated_ref_id(::std::string* ref_id) {
  if (ref_id != NULL) {
    set_has_ref_id();
  } else {
    clear_has_ref_id();
  }
  ref_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_id);
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGPaint.ref_id)
}

// optional bool paint_off = 3;
inline bool ProtoSVGPaint::has_paint_off() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGPaint::set_has_paint_off() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGPaint::clear_has_paint_off() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGPaint::clear_paint_off() {
  paint_off_ = false;
  clear_has_paint_off();
}
inline bool ProtoSVGPaint::paint_off() const {
  // @@protoc_insertion_point(field_get:ProtoSVGPaint.paint_off)
  return paint_off_;
}
inline void ProtoSVGPaint::set_paint_off(bool value) {
  set_has_paint_off();
  paint_off_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGPaint.paint_off)
}

// optional bool odd = 4 [default = false];
inline bool ProtoSVGPaint::has_odd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGPaint::set_has_odd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGPaint::clear_has_odd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGPaint::clear_odd() {
  odd_ = false;
  clear_has_odd();
}
inline bool ProtoSVGPaint::odd() const {
  // @@protoc_insertion_point(field_get:ProtoSVGPaint.odd)
  return odd_;
}
inline void ProtoSVGPaint::set_odd(bool value) {
  set_has_odd();
  odd_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGPaint.odd)
}

// optional float stroke_width = 5 [default = 1];
inline bool ProtoSVGPaint::has_stroke_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoSVGPaint::set_has_stroke_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoSVGPaint::clear_has_stroke_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoSVGPaint::clear_stroke_width() {
  stroke_width_ = 1;
  clear_has_stroke_width();
}
inline float ProtoSVGPaint::stroke_width() const {
  // @@protoc_insertion_point(field_get:ProtoSVGPaint.stroke_width)
  return stroke_width_;
}
inline void ProtoSVGPaint::set_stroke_width(float value) {
  set_has_stroke_width();
  stroke_width_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGPaint.stroke_width)
}

// -------------------------------------------------------------------

// ProtoSVGGeneralParams

// repeated .ProtoSVGElement childs = 1;
inline int ProtoSVGGeneralParams::childs_size() const {
  return childs_.size();
}
inline void ProtoSVGGeneralParams::clear_childs() {
  childs_.Clear();
}
inline const ::ProtoSVGElement& ProtoSVGGeneralParams::childs(int index) const {
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.childs)
  return childs_.Get(index);
}
inline ::ProtoSVGElement* ProtoSVGGeneralParams::mutable_childs(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoSVGGeneralParams.childs)
  return childs_.Mutable(index);
}
inline ::ProtoSVGElement* ProtoSVGGeneralParams::add_childs() {
  // @@protoc_insertion_point(field_add:ProtoSVGGeneralParams.childs)
  return childs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoSVGElement >*
ProtoSVGGeneralParams::mutable_childs() {
  // @@protoc_insertion_point(field_mutable_list:ProtoSVGGeneralParams.childs)
  return &childs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElement >&
ProtoSVGGeneralParams::childs() const {
  // @@protoc_insertion_point(field_list:ProtoSVGGeneralParams.childs)
  return childs_;
}

// optional string id = 2;
inline bool ProtoSVGGeneralParams::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGGeneralParams::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGGeneralParams::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGGeneralParams::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ProtoSVGGeneralParams::id() const {
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.id)
  return id_.GetNoArena();
}
inline void ProtoSVGGeneralParams::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ProtoSVGGeneralParams.id)
}
#if LANG_CXX11
inline void ProtoSVGGeneralParams::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ProtoSVGGeneralParams.id)
}
#endif
inline void ProtoSVGGeneralParams::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ProtoSVGGeneralParams.id)
}
inline void ProtoSVGGeneralParams::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ProtoSVGGeneralParams.id)
}
inline ::std::string* ProtoSVGGeneralParams::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ProtoSVGGeneralParams.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProtoSVGGeneralParams::release_id() {
  // @@protoc_insertion_point(field_release:ProtoSVGGeneralParams.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProtoSVGGeneralParams::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGGeneralParams.id)
}

// optional .ProtoSVGPaint fill = 3;
inline bool ProtoSVGGeneralParams::has_fill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGGeneralParams::set_has_fill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGGeneralParams::clear_has_fill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGGeneralParams::clear_fill() {
  if (fill_ != NULL) fill_->Clear();
  clear_has_fill();
}
inline const ::ProtoSVGPaint& ProtoSVGGeneralParams::fill() const {
  const ::ProtoSVGPaint* p = fill_;
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.fill)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGPaint*>(
      &::_ProtoSVGPaint_default_instance_);
}
inline ::ProtoSVGPaint* ProtoSVGGeneralParams::release_fill() {
  // @@protoc_insertion_point(field_release:ProtoSVGGeneralParams.fill)
  clear_has_fill();
  ::ProtoSVGPaint* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline ::ProtoSVGPaint* ProtoSVGGeneralParams::mutable_fill() {
  set_has_fill();
  if (fill_ == NULL) {
    fill_ = new ::ProtoSVGPaint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGGeneralParams.fill)
  return fill_;
}
inline void ProtoSVGGeneralParams::set_allocated_fill(::ProtoSVGPaint* fill) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fill_;
  }
  if (fill) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fill = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fill, submessage_arena);
    }
    set_has_fill();
  } else {
    clear_has_fill();
  }
  fill_ = fill;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGGeneralParams.fill)
}

// optional .ProtoSVGPaint stroke = 4;
inline bool ProtoSVGGeneralParams::has_stroke() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGGeneralParams::set_has_stroke() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGGeneralParams::clear_has_stroke() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGGeneralParams::clear_stroke() {
  if (stroke_ != NULL) stroke_->Clear();
  clear_has_stroke();
}
inline const ::ProtoSVGPaint& ProtoSVGGeneralParams::stroke() const {
  const ::ProtoSVGPaint* p = stroke_;
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.stroke)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGPaint*>(
      &::_ProtoSVGPaint_default_instance_);
}
inline ::ProtoSVGPaint* ProtoSVGGeneralParams::release_stroke() {
  // @@protoc_insertion_point(field_release:ProtoSVGGeneralParams.stroke)
  clear_has_stroke();
  ::ProtoSVGPaint* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
inline ::ProtoSVGPaint* ProtoSVGGeneralParams::mutable_stroke() {
  set_has_stroke();
  if (stroke_ == NULL) {
    stroke_ = new ::ProtoSVGPaint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGGeneralParams.stroke)
  return stroke_;
}
inline void ProtoSVGGeneralParams::set_allocated_stroke(::ProtoSVGPaint* stroke) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stroke_;
  }
  if (stroke) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stroke = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stroke, submessage_arena);
    }
    set_has_stroke();
  } else {
    clear_has_stroke();
  }
  stroke_ = stroke;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGGeneralParams.stroke)
}

// optional .ProtoAffineTransformMatrix transform = 5;
inline bool ProtoSVGGeneralParams::has_transform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGGeneralParams::set_has_transform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGGeneralParams::clear_has_transform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGGeneralParams::clear_transform() {
  if (transform_ != NULL) transform_->Clear();
  clear_has_transform();
}
inline const ::ProtoAffineTransformMatrix& ProtoSVGGeneralParams::transform() const {
  const ::ProtoAffineTransformMatrix* p = transform_;
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.transform)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoAffineTransformMatrix*>(
      &::_ProtoAffineTransformMatrix_default_instance_);
}
inline ::ProtoAffineTransformMatrix* ProtoSVGGeneralParams::release_transform() {
  // @@protoc_insertion_point(field_release:ProtoSVGGeneralParams.transform)
  clear_has_transform();
  ::ProtoAffineTransformMatrix* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline ::ProtoAffineTransformMatrix* ProtoSVGGeneralParams::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) {
    transform_ = new ::ProtoAffineTransformMatrix;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGGeneralParams.transform)
  return transform_;
}
inline void ProtoSVGGeneralParams::set_allocated_transform(::ProtoAffineTransformMatrix* transform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transform_;
  }
  if (transform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    set_has_transform();
  } else {
    clear_has_transform();
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGGeneralParams.transform)
}

// optional float opacity = 6 [default = 1];
inline bool ProtoSVGGeneralParams::has_opacity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoSVGGeneralParams::set_has_opacity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoSVGGeneralParams::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoSVGGeneralParams::clear_opacity() {
  opacity_ = 1;
  clear_has_opacity();
}
inline float ProtoSVGGeneralParams::opacity() const {
  // @@protoc_insertion_point(field_get:ProtoSVGGeneralParams.opacity)
  return opacity_;
}
inline void ProtoSVGGeneralParams::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGGeneralParams.opacity)
}

// -------------------------------------------------------------------

// ProtoSVGElementGradient_GradientStop

// optional float offset = 1;
inline bool ProtoSVGElementGradient_GradientStop::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGElementGradient_GradientStop::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline float ProtoSVGElementGradient_GradientStop::offset() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.GradientStop.offset)
  return offset_;
}
inline void ProtoSVGElementGradient_GradientStop::set_offset(float value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementGradient.GradientStop.offset)
}

// optional .ProtoColor color = 2;
inline bool ProtoSVGElementGradient_GradientStop::has_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGElementGradient_GradientStop::set_has_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_has_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_color() {
  if (color_ != NULL) color_->Clear();
  clear_has_color();
}
inline const ::ProtoColor& ProtoSVGElementGradient_GradientStop::color() const {
  const ::ProtoColor* p = color_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.GradientStop.color)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoColor*>(
      &::_ProtoColor_default_instance_);
}
inline ::ProtoColor* ProtoSVGElementGradient_GradientStop::release_color() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.GradientStop.color)
  clear_has_color();
  ::ProtoColor* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::ProtoColor* ProtoSVGElementGradient_GradientStop::mutable_color() {
  set_has_color();
  if (color_ == NULL) {
    color_ = new ::ProtoColor;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.GradientStop.color)
  return color_;
}
inline void ProtoSVGElementGradient_GradientStop::set_allocated_color(::ProtoColor* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    set_has_color();
  } else {
    clear_has_color();
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.GradientStop.color)
}

// optional float alpha = 3;
inline bool ProtoSVGElementGradient_GradientStop::has_alpha() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGElementGradient_GradientStop::set_has_alpha() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGElementGradient_GradientStop::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline float ProtoSVGElementGradient_GradientStop::alpha() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.GradientStop.alpha)
  return alpha_;
}
inline void ProtoSVGElementGradient_GradientStop::set_alpha(float value) {
  set_has_alpha();
  alpha_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementGradient.GradientStop.alpha)
}

// -------------------------------------------------------------------

// ProtoSVGElementGradient

// optional .ProtoSVGGeneralParams params = 1;
inline bool ProtoSVGElementGradient::has_params() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGElementGradient::set_has_params() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGElementGradient::clear_has_params() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGElementGradient::clear_params() {
  if (params_ != NULL) params_->Clear();
  clear_has_params();
}
inline const ::ProtoSVGGeneralParams& ProtoSVGElementGradient::params() const {
  const ::ProtoSVGGeneralParams* p = params_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.params)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGGeneralParams*>(
      &::_ProtoSVGGeneralParams_default_instance_);
}
inline ::ProtoSVGGeneralParams* ProtoSVGElementGradient::release_params() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.params)
  clear_has_params();
  ::ProtoSVGGeneralParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::ProtoSVGGeneralParams* ProtoSVGElementGradient::mutable_params() {
  set_has_params();
  if (params_ == NULL) {
    params_ = new ::ProtoSVGGeneralParams;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.params)
  return params_;
}
inline void ProtoSVGElementGradient::set_allocated_params(::ProtoSVGGeneralParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    set_has_params();
  } else {
    clear_has_params();
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.params)
}

// repeated .ProtoSVGElementGradient.GradientStop stops = 3;
inline int ProtoSVGElementGradient::stops_size() const {
  return stops_.size();
}
inline void ProtoSVGElementGradient::clear_stops() {
  stops_.Clear();
}
inline const ::ProtoSVGElementGradient_GradientStop& ProtoSVGElementGradient::stops(int index) const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.stops)
  return stops_.Get(index);
}
inline ::ProtoSVGElementGradient_GradientStop* ProtoSVGElementGradient::mutable_stops(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.stops)
  return stops_.Mutable(index);
}
inline ::ProtoSVGElementGradient_GradientStop* ProtoSVGElementGradient::add_stops() {
  // @@protoc_insertion_point(field_add:ProtoSVGElementGradient.stops)
  return stops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementGradient_GradientStop >*
ProtoSVGElementGradient::mutable_stops() {
  // @@protoc_insertion_point(field_mutable_list:ProtoSVGElementGradient.stops)
  return &stops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementGradient_GradientStop >&
ProtoSVGElementGradient::stops() const {
  // @@protoc_insertion_point(field_list:ProtoSVGElementGradient.stops)
  return stops_;
}

// optional .ProtoAffineTransformMatrix gradientTransform = 4;
inline bool ProtoSVGElementGradient::has_gradienttransform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGElementGradient::set_has_gradienttransform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGElementGradient::clear_has_gradienttransform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGElementGradient::clear_gradienttransform() {
  if (gradienttransform_ != NULL) gradienttransform_->Clear();
  clear_has_gradienttransform();
}
inline const ::ProtoAffineTransformMatrix& ProtoSVGElementGradient::gradienttransform() const {
  const ::ProtoAffineTransformMatrix* p = gradienttransform_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.gradientTransform)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoAffineTransformMatrix*>(
      &::_ProtoAffineTransformMatrix_default_instance_);
}
inline ::ProtoAffineTransformMatrix* ProtoSVGElementGradient::release_gradienttransform() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.gradientTransform)
  clear_has_gradienttransform();
  ::ProtoAffineTransformMatrix* temp = gradienttransform_;
  gradienttransform_ = NULL;
  return temp;
}
inline ::ProtoAffineTransformMatrix* ProtoSVGElementGradient::mutable_gradienttransform() {
  set_has_gradienttransform();
  if (gradienttransform_ == NULL) {
    gradienttransform_ = new ::ProtoAffineTransformMatrix;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.gradientTransform)
  return gradienttransform_;
}
inline void ProtoSVGElementGradient::set_allocated_gradienttransform(::ProtoAffineTransformMatrix* gradienttransform) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gradienttransform_;
  }
  if (gradienttransform) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gradienttransform = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gradienttransform, submessage_arena);
    }
    set_has_gradienttransform();
  } else {
    clear_has_gradienttransform();
  }
  gradienttransform_ = gradienttransform;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.gradientTransform)
}

// optional .ProtoPoint startPoint = 5;
inline bool ProtoSVGElementGradient::has_startpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGElementGradient::set_has_startpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGElementGradient::clear_has_startpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGElementGradient::clear_startpoint() {
  if (startpoint_ != NULL) startpoint_->Clear();
  clear_has_startpoint();
}
inline const ::ProtoPoint& ProtoSVGElementGradient::startpoint() const {
  const ::ProtoPoint* p = startpoint_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.startPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementGradient::release_startpoint() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.startPoint)
  clear_has_startpoint();
  ::ProtoPoint* temp = startpoint_;
  startpoint_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementGradient::mutable_startpoint() {
  set_has_startpoint();
  if (startpoint_ == NULL) {
    startpoint_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.startPoint)
  return startpoint_;
}
inline void ProtoSVGElementGradient::set_allocated_startpoint(::ProtoPoint* startpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete startpoint_;
  }
  if (startpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      startpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, startpoint, submessage_arena);
    }
    set_has_startpoint();
  } else {
    clear_has_startpoint();
  }
  startpoint_ = startpoint;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.startPoint)
}

// optional .ProtoPoint endPoint = 6;
inline bool ProtoSVGElementGradient::has_endpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGElementGradient::set_has_endpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGElementGradient::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGElementGradient::clear_endpoint() {
  if (endpoint_ != NULL) endpoint_->Clear();
  clear_has_endpoint();
}
inline const ::ProtoPoint& ProtoSVGElementGradient::endpoint() const {
  const ::ProtoPoint* p = endpoint_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.endPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementGradient::release_endpoint() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.endPoint)
  clear_has_endpoint();
  ::ProtoPoint* temp = endpoint_;
  endpoint_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementGradient::mutable_endpoint() {
  set_has_endpoint();
  if (endpoint_ == NULL) {
    endpoint_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.endPoint)
  return endpoint_;
}
inline void ProtoSVGElementGradient::set_allocated_endpoint(::ProtoPoint* endpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete endpoint_;
  }
  if (endpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      endpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.endPoint)
}

// optional .ProtoPoint center = 7;
inline bool ProtoSVGElementGradient::has_center() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoSVGElementGradient::set_has_center() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoSVGElementGradient::clear_has_center() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoSVGElementGradient::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::ProtoPoint& ProtoSVGElementGradient::center() const {
  const ::ProtoPoint* p = center_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.center)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementGradient::release_center() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.center)
  clear_has_center();
  ::ProtoPoint* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementGradient::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    center_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.center)
  return center_;
}
inline void ProtoSVGElementGradient::set_allocated_center(::ProtoPoint* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.center)
}

// optional float r = 8;
inline bool ProtoSVGElementGradient::has_r() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoSVGElementGradient::set_has_r() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoSVGElementGradient::clear_has_r() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoSVGElementGradient::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float ProtoSVGElementGradient::r() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.r)
  return r_;
}
inline void ProtoSVGElementGradient::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementGradient.r)
}

// optional .ProtoPoint focusPoint = 9;
inline bool ProtoSVGElementGradient::has_focuspoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoSVGElementGradient::set_has_focuspoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoSVGElementGradient::clear_has_focuspoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoSVGElementGradient::clear_focuspoint() {
  if (focuspoint_ != NULL) focuspoint_->Clear();
  clear_has_focuspoint();
}
inline const ::ProtoPoint& ProtoSVGElementGradient::focuspoint() const {
  const ::ProtoPoint* p = focuspoint_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.focusPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementGradient::release_focuspoint() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementGradient.focusPoint)
  clear_has_focuspoint();
  ::ProtoPoint* temp = focuspoint_;
  focuspoint_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementGradient::mutable_focuspoint() {
  set_has_focuspoint();
  if (focuspoint_ == NULL) {
    focuspoint_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementGradient.focusPoint)
  return focuspoint_;
}
inline void ProtoSVGElementGradient::set_allocated_focuspoint(::ProtoPoint* focuspoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete focuspoint_;
  }
  if (focuspoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      focuspoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, focuspoint, submessage_arena);
    }
    set_has_focuspoint();
  } else {
    clear_has_focuspoint();
  }
  focuspoint_ = focuspoint;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementGradient.focusPoint)
}

// optional bool gradientUnits_IsUserSpace = 10 [default = true];
inline bool ProtoSVGElementGradient::has_gradientunits_isuserspace() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoSVGElementGradient::set_has_gradientunits_isuserspace() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoSVGElementGradient::clear_has_gradientunits_isuserspace() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoSVGElementGradient::clear_gradientunits_isuserspace() {
  gradientunits_isuserspace_ = true;
  clear_has_gradientunits_isuserspace();
}
inline bool ProtoSVGElementGradient::gradientunits_isuserspace() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementGradient.gradientUnits_IsUserSpace)
  return gradientunits_isuserspace_;
}
inline void ProtoSVGElementGradient::set_gradientunits_isuserspace(bool value) {
  set_has_gradientunits_isuserspace();
  gradientunits_isuserspace_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementGradient.gradientUnits_IsUserSpace)
}

// -------------------------------------------------------------------

// ProtoSVGElementPath_PathPoint

// optional .ProtoPoint move_to = 1;
inline bool ProtoSVGElementPath_PathPoint::has_move_to() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGElementPath_PathPoint::set_has_move_to() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGElementPath_PathPoint::clear_has_move_to() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGElementPath_PathPoint::clear_move_to() {
  if (move_to_ != NULL) move_to_->Clear();
  clear_has_move_to();
}
inline const ::ProtoPoint& ProtoSVGElementPath_PathPoint::move_to() const {
  const ::ProtoPoint* p = move_to_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.PathPoint.move_to)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementPath_PathPoint::release_move_to() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementPath.PathPoint.move_to)
  clear_has_move_to();
  ::ProtoPoint* temp = move_to_;
  move_to_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementPath_PathPoint::mutable_move_to() {
  set_has_move_to();
  if (move_to_ == NULL) {
    move_to_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.PathPoint.move_to)
  return move_to_;
}
inline void ProtoSVGElementPath_PathPoint::set_allocated_move_to(::ProtoPoint* move_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete move_to_;
  }
  if (move_to) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      move_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, move_to, submessage_arena);
    }
    set_has_move_to();
  } else {
    clear_has_move_to();
  }
  move_to_ = move_to;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementPath.PathPoint.move_to)
}

// optional .ProtoPoint line_to = 2;
inline bool ProtoSVGElementPath_PathPoint::has_line_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGElementPath_PathPoint::set_has_line_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGElementPath_PathPoint::clear_has_line_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGElementPath_PathPoint::clear_line_to() {
  if (line_to_ != NULL) line_to_->Clear();
  clear_has_line_to();
}
inline const ::ProtoPoint& ProtoSVGElementPath_PathPoint::line_to() const {
  const ::ProtoPoint* p = line_to_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.PathPoint.line_to)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoPoint*>(
      &::_ProtoPoint_default_instance_);
}
inline ::ProtoPoint* ProtoSVGElementPath_PathPoint::release_line_to() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementPath.PathPoint.line_to)
  clear_has_line_to();
  ::ProtoPoint* temp = line_to_;
  line_to_ = NULL;
  return temp;
}
inline ::ProtoPoint* ProtoSVGElementPath_PathPoint::mutable_line_to() {
  set_has_line_to();
  if (line_to_ == NULL) {
    line_to_ = new ::ProtoPoint;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.PathPoint.line_to)
  return line_to_;
}
inline void ProtoSVGElementPath_PathPoint::set_allocated_line_to(::ProtoPoint* line_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete line_to_;
  }
  if (line_to) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      line_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, line_to, submessage_arena);
    }
    set_has_line_to();
  } else {
    clear_has_line_to();
  }
  line_to_ = line_to;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementPath.PathPoint.line_to)
}

// optional .ProtoCurve curve_to = 3;
inline bool ProtoSVGElementPath_PathPoint::has_curve_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGElementPath_PathPoint::set_has_curve_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGElementPath_PathPoint::clear_has_curve_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGElementPath_PathPoint::clear_curve_to() {
  if (curve_to_ != NULL) curve_to_->Clear();
  clear_has_curve_to();
}
inline const ::ProtoCurve& ProtoSVGElementPath_PathPoint::curve_to() const {
  const ::ProtoCurve* p = curve_to_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.PathPoint.curve_to)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoCurve*>(
      &::_ProtoCurve_default_instance_);
}
inline ::ProtoCurve* ProtoSVGElementPath_PathPoint::release_curve_to() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementPath.PathPoint.curve_to)
  clear_has_curve_to();
  ::ProtoCurve* temp = curve_to_;
  curve_to_ = NULL;
  return temp;
}
inline ::ProtoCurve* ProtoSVGElementPath_PathPoint::mutable_curve_to() {
  set_has_curve_to();
  if (curve_to_ == NULL) {
    curve_to_ = new ::ProtoCurve;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.PathPoint.curve_to)
  return curve_to_;
}
inline void ProtoSVGElementPath_PathPoint::set_allocated_curve_to(::ProtoCurve* curve_to) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete curve_to_;
  }
  if (curve_to) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      curve_to = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, curve_to, submessage_arena);
    }
    set_has_curve_to();
  } else {
    clear_has_curve_to();
  }
  curve_to_ = curve_to;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementPath.PathPoint.curve_to)
}

// optional bool close_path = 4 [default = false];
inline bool ProtoSVGElementPath_PathPoint::has_close_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGElementPath_PathPoint::set_has_close_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGElementPath_PathPoint::clear_has_close_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGElementPath_PathPoint::clear_close_path() {
  close_path_ = false;
  clear_has_close_path();
}
inline bool ProtoSVGElementPath_PathPoint::close_path() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.PathPoint.close_path)
  return close_path_;
}
inline void ProtoSVGElementPath_PathPoint::set_close_path(bool value) {
  set_has_close_path();
  close_path_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.PathPoint.close_path)
}

// -------------------------------------------------------------------

// ProtoSVGElementPath

// optional .ProtoSVGGeneralParams params = 1;
inline bool ProtoSVGElementPath::has_params() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGElementPath::set_has_params() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGElementPath::clear_has_params() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGElementPath::clear_params() {
  if (params_ != NULL) params_->Clear();
  clear_has_params();
}
inline const ::ProtoSVGGeneralParams& ProtoSVGElementPath::params() const {
  const ::ProtoSVGGeneralParams* p = params_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.params)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGGeneralParams*>(
      &::_ProtoSVGGeneralParams_default_instance_);
}
inline ::ProtoSVGGeneralParams* ProtoSVGElementPath::release_params() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementPath.params)
  clear_has_params();
  ::ProtoSVGGeneralParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::ProtoSVGGeneralParams* ProtoSVGElementPath::mutable_params() {
  set_has_params();
  if (params_ == NULL) {
    params_ = new ::ProtoSVGGeneralParams;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.params)
  return params_;
}
inline void ProtoSVGElementPath::set_allocated_params(::ProtoSVGGeneralParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    set_has_params();
  } else {
    clear_has_params();
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementPath.params)
}

// repeated .ProtoSVGElementPath.PathPoint points = 3;
inline int ProtoSVGElementPath::points_size() const {
  return points_.size();
}
inline void ProtoSVGElementPath::clear_points() {
  points_.Clear();
}
inline const ::ProtoSVGElementPath_PathPoint& ProtoSVGElementPath::points(int index) const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.points)
  return points_.Get(index);
}
inline ::ProtoSVGElementPath_PathPoint* ProtoSVGElementPath::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.points)
  return points_.Mutable(index);
}
inline ::ProtoSVGElementPath_PathPoint* ProtoSVGElementPath::add_points() {
  // @@protoc_insertion_point(field_add:ProtoSVGElementPath.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementPath_PathPoint >*
ProtoSVGElementPath::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:ProtoSVGElementPath.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoSVGElementPath_PathPoint >&
ProtoSVGElementPath::points() const {
  // @@protoc_insertion_point(field_list:ProtoSVGElementPath.points)
  return points_;
}

// optional float cx = 4;
inline bool ProtoSVGElementPath::has_cx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGElementPath::set_has_cx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGElementPath::clear_has_cx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGElementPath::clear_cx() {
  cx_ = 0;
  clear_has_cx();
}
inline float ProtoSVGElementPath::cx() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.cx)
  return cx_;
}
inline void ProtoSVGElementPath::set_cx(float value) {
  set_has_cx();
  cx_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.cx)
}

// optional float cy = 5;
inline bool ProtoSVGElementPath::has_cy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSVGElementPath::set_has_cy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSVGElementPath::clear_has_cy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSVGElementPath::clear_cy() {
  cy_ = 0;
  clear_has_cy();
}
inline float ProtoSVGElementPath::cy() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.cy)
  return cy_;
}
inline void ProtoSVGElementPath::set_cy(float value) {
  set_has_cy();
  cy_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.cy)
}

// optional float rx = 6;
inline bool ProtoSVGElementPath::has_rx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoSVGElementPath::set_has_rx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoSVGElementPath::clear_has_rx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoSVGElementPath::clear_rx() {
  rx_ = 0;
  clear_has_rx();
}
inline float ProtoSVGElementPath::rx() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.rx)
  return rx_;
}
inline void ProtoSVGElementPath::set_rx(float value) {
  set_has_rx();
  rx_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.rx)
}

// optional float ry = 7;
inline bool ProtoSVGElementPath::has_ry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoSVGElementPath::set_has_ry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoSVGElementPath::clear_has_ry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoSVGElementPath::clear_ry() {
  ry_ = 0;
  clear_has_ry();
}
inline float ProtoSVGElementPath::ry() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.ry)
  return ry_;
}
inline void ProtoSVGElementPath::set_ry(float value) {
  set_has_ry();
  ry_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.ry)
}

// optional float r = 8;
inline bool ProtoSVGElementPath::has_r() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoSVGElementPath::set_has_r() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoSVGElementPath::clear_has_r() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoSVGElementPath::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float ProtoSVGElementPath::r() const {
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.r)
  return r_;
}
inline void ProtoSVGElementPath::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:ProtoSVGElementPath.r)
}

// optional .ProtoRect rect = 9;
inline bool ProtoSVGElementPath::has_rect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGElementPath::set_has_rect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGElementPath::clear_has_rect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGElementPath::clear_rect() {
  if (rect_ != NULL) rect_->Clear();
  clear_has_rect();
}
inline const ::ProtoRect& ProtoSVGElementPath::rect() const {
  const ::ProtoRect* p = rect_;
  // @@protoc_insertion_point(field_get:ProtoSVGElementPath.rect)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoRect*>(
      &::_ProtoRect_default_instance_);
}
inline ::ProtoRect* ProtoSVGElementPath::release_rect() {
  // @@protoc_insertion_point(field_release:ProtoSVGElementPath.rect)
  clear_has_rect();
  ::ProtoRect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline ::ProtoRect* ProtoSVGElementPath::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) {
    rect_ = new ::ProtoRect;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGElementPath.rect)
  return rect_;
}
inline void ProtoSVGElementPath::set_allocated_rect(::ProtoRect* rect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rect_;
  }
  if (rect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    set_has_rect();
  } else {
    clear_has_rect();
  }
  rect_ = rect;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGElementPath.rect)
}

// -------------------------------------------------------------------

// ProtoSVGRoot

// optional .ProtoSVGGeneralParams params = 1;
inline bool ProtoSVGRoot::has_params() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSVGRoot::set_has_params() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSVGRoot::clear_has_params() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSVGRoot::clear_params() {
  if (params_ != NULL) params_->Clear();
  clear_has_params();
}
inline const ::ProtoSVGGeneralParams& ProtoSVGRoot::params() const {
  const ::ProtoSVGGeneralParams* p = params_;
  // @@protoc_insertion_point(field_get:ProtoSVGRoot.params)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoSVGGeneralParams*>(
      &::_ProtoSVGGeneralParams_default_instance_);
}
inline ::ProtoSVGGeneralParams* ProtoSVGRoot::release_params() {
  // @@protoc_insertion_point(field_release:ProtoSVGRoot.params)
  clear_has_params();
  ::ProtoSVGGeneralParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::ProtoSVGGeneralParams* ProtoSVGRoot::mutable_params() {
  set_has_params();
  if (params_ == NULL) {
    params_ = new ::ProtoSVGGeneralParams;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGRoot.params)
  return params_;
}
inline void ProtoSVGRoot::set_allocated_params(::ProtoSVGGeneralParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    set_has_params();
  } else {
    clear_has_params();
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGRoot.params)
}

// optional .ProtoRect frame = 2;
inline bool ProtoSVGRoot::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSVGRoot::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSVGRoot::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSVGRoot::clear_frame() {
  if (frame_ != NULL) frame_->Clear();
  clear_has_frame();
}
inline const ::ProtoRect& ProtoSVGRoot::frame() const {
  const ::ProtoRect* p = frame_;
  // @@protoc_insertion_point(field_get:ProtoSVGRoot.frame)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoRect*>(
      &::_ProtoRect_default_instance_);
}
inline ::ProtoRect* ProtoSVGRoot::release_frame() {
  // @@protoc_insertion_point(field_release:ProtoSVGRoot.frame)
  clear_has_frame();
  ::ProtoRect* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline ::ProtoRect* ProtoSVGRoot::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) {
    frame_ = new ::ProtoRect;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGRoot.frame)
  return frame_;
}
inline void ProtoSVGRoot::set_allocated_frame(::ProtoRect* frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete frame_;
  }
  if (frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frame, submessage_arena);
    }
    set_has_frame();
  } else {
    clear_has_frame();
  }
  frame_ = frame;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGRoot.frame)
}

// optional .ProtoRect bounds = 3;
inline bool ProtoSVGRoot::has_bounds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSVGRoot::set_has_bounds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSVGRoot::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSVGRoot::clear_bounds() {
  if (bounds_ != NULL) bounds_->Clear();
  clear_has_bounds();
}
inline const ::ProtoRect& ProtoSVGRoot::bounds() const {
  const ::ProtoRect* p = bounds_;
  // @@protoc_insertion_point(field_get:ProtoSVGRoot.bounds)
  return p != NULL ? *p : *reinterpret_cast<const ::ProtoRect*>(
      &::_ProtoRect_default_instance_);
}
inline ::ProtoRect* ProtoSVGRoot::release_bounds() {
  // @@protoc_insertion_point(field_release:ProtoSVGRoot.bounds)
  clear_has_bounds();
  ::ProtoRect* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline ::ProtoRect* ProtoSVGRoot::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) {
    bounds_ = new ::ProtoRect;
  }
  // @@protoc_insertion_point(field_mutable:ProtoSVGRoot.bounds)
  return bounds_;
}
inline void ProtoSVGRoot::set_allocated_bounds(::ProtoRect* bounds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bounds_;
  }
  if (bounds) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bounds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    set_has_bounds();
  } else {
    clear_has_bounds();
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:ProtoSVGRoot.bounds)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_svg_2eproto__INCLUDED
